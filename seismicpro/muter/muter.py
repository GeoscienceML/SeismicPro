"""Implements Muter class to define a boundary above which gather values should be zeroed out"""

import numpy as np

from ..utils import VFUNC


class Muter(VFUNC):
    """A class to define an offset-time boundary above which gather values should be muted i.e. zeroed out.

    Usually muting is performed to attenuate any strong, coherent noise that was generated by a shot, e.g. high
    amplitudes near the first breaks. Such kind of noise strongly affects several processing routines, such as
    :func:`~Gather.calculate_vertical_velocity_spectrum`.

    A muter object can be instantiated directly by passing arrays of offsets and times defining knots of a piecewise
    linear muting boundary or created from other types of data by calling a corresponding `classmethod`:
    * `from_file` - from a file in VFUNC format with offset-time pairs,
    * `from_muters` - from other muters with given weights,
    * `from_refractor_velocity` - from a near-surface velocity model to attenuate high amplitudes immediately following
      the first breaks.

    The created object is callable and returns times up to which muting should be performed for given offsets.

    Examples
    --------
    Create a muter from arrays of offsets and times:
    >>> muter = Muter(offsets=[100, 1000, 2000], times=[200, 2000, 3000])
    >>> muter([0, 100, 500, 1000, 1500, 2000])
    array([   0.,  200., 1000., 2000., 2500., 3000.])

    Now a gather can be muted using a created object:
    >>> gather = survey.sample_gather()
    >>> gather.mute(muter)

    Parameters
    ----------
    offsets : 1d array-like
        An array with offset values for which muting times are selected. Measured in meters.
    times : 1d array-like
        An array of muting times, matching the length of `offsets`. Measured in milliseconds.
    coords : Coordinates or None, optional, defaults to None
        Spatial coordinates of the muter. If not given, the created instance won't be able to be added to a
        `MuterField`.

    Attributes
    ----------
    data_x : 1d np.ndarray
        An array with offset values for which muting times are selected. Measured in meters.
    data_y : 1d np.ndarray
        An array of muting times, matching the length of `data_x`. Measured in milliseconds.
    interpolator : callable
        An interpolator returning muting times for given offsets.
    coords : Coordinates or None
        Spatial coordinates of the muter.
    """
    def __init__(self, offsets, times, coords=None):
        super().__init__(offsets, times, coords=coords)

    @property
    def offsets(self):
        """1d np.ndarray: An array with offset values for which muting times are selected. Measured in meters."""
        return self.data_x

    @property
    def times(self):
        """1d np.ndarray: An array of muting times, matching the length of `offsets`. Measured in milliseconds."""
        return self.data_y

    @classmethod
    def from_muters(cls, muters, weights=None, coords=None):
        """Init a muter by averaging other muters with given weights.

        Parameters
        ----------
        muters : Muter or list of Muter
            Muters to be aggregated.
        weights : float or list of floats, optional
            Weight of each item in `muters`. Normalized to have sum of 1 before aggregation. If not given, equal
            weights are assigned to all items and thus mean muter is calculated.
        coords : Coordinates, optional
            Spatial coordinates of the created muter. If not given, the created instance won't be able to be added to a
            `MuterField`.

        Returns
        -------
        self : Muter
            Created muter instance.
        """
        return cls.from_vfuncs(muters, weights, coords)

    @classmethod
    def from_refractor_velocity(cls, refractor_velocity, delay=0, velocity_reduction=0):
        """Create a muter from a velocity model of an upper part of the section.

        This muter is supposed to attenuate high amplitudes immediately following the first breaks and thus its
        offset-time boundary is constructed in the following way:
        1) Reduce velocity of each refractor by `velocity_reduction` to account for imperfect model fit and variability
           of first arrivals at a given offset,
        2) Take an offset-time curve defined by an adjusted `refractor_velocity` from the previous step and shift it by
           `delay` to handle near-offset traces.

        Parameters
        ----------
        refractor_velocity : RefractorVelocity
            A near-surface velocity model to construct a muter from.
        delay : float, optional, defaults to 0
            Introduced constant delay. Measured in milliseconds.
        velocity_reduction : float or array-like of float, optional, defaults to 0
            A value used to decrement velocity of each refractor. If a single `float`, the same value is used for all
            refractors. Measured in meters/seconds.

        Returns
        -------
        self : Muter
            Created muter.
        """
        times, offsets = refractor_velocity.piecewise_times, refractor_velocity.piecewise_offsets
        offsets_diff = np.diff(offsets)
        muting_velocities = offsets_diff / np.diff(times) - np.array(velocity_reduction) / 1000  # m/s to m/ms
        if (muting_velocities <= 0).any():
            raise ValueError("Refractor velocities must remain positive after velocity reduction")

        time_deltas = np.empty_like(times)
        time_deltas[0] = times[0] + delay
        time_deltas[1:] = offsets_diff / muting_velocities
        return cls(offsets, np.cumsum(time_deltas), coords=refractor_velocity.coords)
